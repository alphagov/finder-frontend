# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/aws-xray-sdk/all/aws-xray-sdk.rbi
#
# aws-xray-sdk-0.10.2
module XRay
  def self.recorder; end
end
class XRay::AwsXRaySdkError < StandardError
end
class XRay::EntityClosedError < XRay::AwsXRaySdkError
  def initialize; end
end
class XRay::ContextMissingError < XRay::AwsXRaySdkError
  def initialize; end
end
class XRay::SegmentNameMissingError < XRay::AwsXRaySdkError
end
class XRay::InvalidDaemonAddressError < XRay::AwsXRaySdkError
end
class XRay::InvalidSamplingConfigError < XRay::AwsXRaySdkError
end
class XRay::InvalidConfigurationError < XRay::AwsXRaySdkError
end
class XRay::UnsupportedPatchingTargetError < XRay::AwsXRaySdkError
end
module XRay::Patcher
  def patch(targets); end
end
module XRay::Logging
  def logger; end
  def self.logger; end
  def self.logger=(v); end
end
module XRay::Emitter
  def daemon_address=(v); end
  def send_entity(entity:); end
end
class XRay::DefaultEmitter
  def address; end
  def configure_socket(v); end
  def daemon_address=(v); end
  def initialize; end
  def send_entity(entity:); end
  include XRay::Emitter
  include XRay::Logging
end
module XRay::Context
  def clear!; end
  def current_entity; end
  def handle_context_missing; end
  def inject_context(entity, target_ctx: nil); end
  def store_entity(entity:); end
end
class XRay::DefaultContext
  def clear!; end
  def context_missing; end
  def context_missing=(v); end
  def current_entity; end
  def handle_context_missing; end
  def initialize; end
  def inject_context(entity, target_ctx: nil); end
  def sanitize_strategy(v); end
  def store_entity(entity:); end
  include XRay::Context
  include XRay::Logging
end
module XRay::Sampler
  def sample?; end
  def sample_request?(service_name:, url_path:, http_method:); end
  def sampling_rules; end
  def sampling_rules=(v); end
end
class XRay::Reservoir
  def initialize(traces_per_sec: nil); end
  def take; end
end
module XRay::SearchPattern
  def self.simple_wildcard_match?(pattern:, text:); end
  def self.wildcard_match?(pattern:, text:, case_insensitive: nil); end
end
class XRay::SamplingRule
  def applies?(target_name:, target_path:, target_method:); end
  def default; end
  def fixed_target; end
  def initialize(rule_definition:, default: nil); end
  def method; end
  def path; end
  def rate; end
  def reservoir; end
  def service_name; end
  def validate; end
end
class XRay::DefaultSampler
  def initialize; end
  def load_sampling_rules(v); end
  def sample?; end
  def sample_request?(service_name:, url_path:, http_method:); end
  def sampling_rules; end
  def sampling_rules=(v); end
  def should_sample?(rule); end
  include XRay::Sampler
end
module XRay::Streamer
  def eligible?(segment:); end
  def stream_threshold=(v); end
  def subsegments_to_stream(segment:, emitter:, force: nil); end
end
class XRay::DefaultStreamer
  def eligible?(segment:); end
  def initialize; end
  def stream_subsegments(root:, emitter:); end
  def stream_threshold; end
  def stream_threshold=(arg0); end
  include XRay::Logging
  include XRay::Streamer
end
module XRay::SegmentNaming
  def fallback; end
  def fallback=(arg0); end
  def pattern; end
  def pattern=(arg0); end
  def provide_name(host:); end
end
class XRay::DynamicNaming
  def initialize(fallback:); end
  def provide_name(host:); end
  include XRay::SegmentNaming
end
module XRay::Plugins
end
module XRay::Plugins::EC2
  def self.aws; end
  include XRay::Logging
end
module XRay::Plugins::ECS
  def self.aws; end
  include XRay::Logging
end
module XRay::Plugins::ElasticBeanstalk
  def self.aws; end
  include XRay::Logging
end
class XRay::Configuration
  def configure(user_config); end
  def context; end
  def context=(arg0); end
  def context_missing=(v); end
  def daemon_address=(v); end
  def emitter; end
  def emitter=(arg0); end
  def initialize; end
  def load_plugins(symbols); end
  def logger; end
  def name; end
  def name=(v); end
  def naming_pattern=(v); end
  def plugins; end
  def plugins=(arg0); end
  def sample?; end
  def sampler; end
  def sampler=(arg0); end
  def sampling; end
  def sampling=(arg0); end
  def sampling_rules=(v); end
  def segment_naming; end
  def segment_naming=(arg0); end
  def stream_threshold=(v); end
  def streamer; end
  def streamer=(arg0); end
  include XRay::Patcher
end
class XRay::Cause
  def id; end
  def initialize(exception: nil, id: nil, remote: nil); end
  def normalize(e:, remote: nil); end
  def normalize_exception(e:, remote: nil); end
  def to_h; end
  def to_json; end
end
class XRay::Annotations
  def [](key); end
  def []=(k, v); end
  def filter_annotations(h); end
  def initialize(entity); end
  def key_supported?(k); end
  def sanitize_values(h); end
  def to_h; end
  def update(h); end
  def value_supported?(v); end
  include XRay::Logging
end
module XRay::FacadeAnnotations
  def self.[](key); end
  def self.[]=(k, v); end
  def self.to_h; end
  def self.update(h); end
end
class XRay::Metadata
  def initialize(entity); end
  def sub_meta(namespace); end
  def to_h; end
end
class XRay::SubMeta
  def [](key); end
  def []=(k, v); end
  def initialize(entity); end
  def to_h; end
  def to_json; end
  def update(h); end
end
module XRay::FacadeMetadata
  def self.[](key); end
  def self.[]=(k, v); end
  def self.to_h; end
  def self.update(h); end
end
module XRay::Entity
  def add_exception(exception:, remote: nil); end
  def add_subsegment(subsegment:); end
  def annotations; end
  def apply_status_code(status:); end
  def aws; end
  def aws=(arg0); end
  def cause; end
  def cause_id; end
  def close(end_time: nil); end
  def closed?; end
  def end_time; end
  def end_time=(arg0); end
  def error; end
  def error=(arg0); end
  def exception; end
  def fault; end
  def fault=(arg0); end
  def find_root_cause(e); end
  def http_request; end
  def http_response; end
  def id; end
  def merge_http_request(request:); end
  def merge_http_response(response:); end
  def metadata(namespace: nil); end
  def name; end
  def namespace; end
  def parent; end
  def parent=(arg0); end
  def remove_subsegment(subsegment:); end
  def sampled; end
  def sampled=(arg0); end
  def start_time; end
  def start_time=(arg0); end
  def subsegments; end
  def throttle; end
  def throttle=(arg0); end
  def to_h; end
  def to_json; end
end
class XRay::Segment
  def add_subsegment(subsegment:); end
  def decrement_ref_counter; end
  def initialize(trace_id: nil, name: nil, parent_id: nil); end
  def origin; end
  def origin=(arg0); end
  def ready_to_send?; end
  def ref_counter; end
  def ref_counter=(arg0); end
  def remove_subsegment(subsegment:); end
  def segment; end
  def service; end
  def service=(arg0); end
  def subsegment_size; end
  def subsegment_size=(arg0); end
  def to_h; end
  def trace_id; end
  def user; end
  def user=(arg0); end
  include XRay::Entity
end
class XRay::Subsegment
  def add_subsegment(subsegment:); end
  def all_children_count; end
  def close(end_time: nil); end
  def initialize(name:, segment:, namespace: nil); end
  def remove_subsegment(subsegment:); end
  def segment; end
  def sql; end
  def sql=(arg0); end
  def to_h; end
  include XRay::Entity
end
module XRay::DummyEntity
  def add_exception(exception:, remote: nil); end
  def annotations; end
  def apply_status_code(status:); end
  def aws=(v); end
  def merge_http_request(request:); end
  def merge_http_response(response:); end
  def metadata(namespace: nil); end
  def sampled; end
  def to_h; end
  def to_json; end
end
class XRay::DummySegment < XRay::Segment
  include XRay::DummyEntity
end
class XRay::DummySubsegment < XRay::Subsegment
  def sql=(v); end
  include XRay::DummyEntity
end
class XRay::Recorder
  def annotations; end
  def begin_segment(name, trace_id: nil, parent_id: nil, sampled: nil); end
  def begin_subsegment(name, namespace: nil, segment: nil); end
  def capture(name, namespace: nil, segment: nil); end
  def clear_context; end
  def config; end
  def configure(user_config); end
  def context; end
  def current_entity; end
  def current_segment; end
  def current_subsegment; end
  def emitter; end
  def end_segment(end_time: nil); end
  def end_subsegment(end_time: nil); end
  def initialize(user_config: nil); end
  def inject_context(entity, target_ctx: nil); end
  def metadata(namespace: nil); end
  def populate_runtime_context(segment); end
  def sampled?; end
  def sampler; end
  def sampling_enabled?; end
  def segment_naming; end
  def streamer; end
end
class XRay::TraceHeader
  def header_string; end
  def initialize(root:, parent_id:, sampled:); end
  def parent_id; end
  def parent_id=(arg0); end
  def root; end
  def root=(arg0); end
  def sampled; end
  def sampled=(arg0); end
  def self.empty_header; end
  def self.from_header_string(header_str:); end
  include XRay::Logging
end
module XRay::Facets
end
module XRay::Facets::Helper
  def construct_header(headers:); end
  def prep_header_str(entity:); end
  def should_sample?(header_obj:, recorder:, host: nil, method: nil, path: nil, **args); end
end
module XRay::Rack
end
class XRay::Rack::Middleware
  def call(env); end
  def extract_request_meta(req); end
  def get_ip(v); end
  def initialize(app, recorder: nil); end
  include XRay::Facets::Helper
end
module XRay::Rails
end
class XRay::Rails::ExceptionMiddleware
  def call(env); end
  def initialize(app, recorder: nil); end
end
